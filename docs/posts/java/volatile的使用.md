---
title: volatile的使用
date: 2024-03-01 15:41:24
tags:
 - 可见性
 - 同步机制
 - java
categories: java
---

## volatile简介

`volatile` 关键字是一种在编程中用于声明变量的修饰符，它告诉编译器这个变量的值可能会被某些编译器无法检测的因素（比如并行执行的线程）改变。在Java和C/C++等语言中，`volatile`的使用和意义略有不同，但核心概念相似——防止编译器对这些变量进行优化，确保每次访问变量时都直接从内存中读取，而不是从寄存器或其他地方读取可能已经过时的值。

### 使用场景

1. **多线程环境下的变量共享**：在多线程程序中，一个线程对非`volatile`变量的修改可能对其他线程不可见，导致程序行为出现错误。使用`volatile`可以确保当一个线程修改了变量的值时，其他线程能够立即看到这个变化。

2. **防止指令重排序**：现代编译器和处理器为了优化性能，可能会对指令序列进行重排序。`volatile`变量的读写操作可以作为一个内存屏障，防止特定类型的重排序，确保在`volatile`变量读写操作之前的所有操作都在内存中完成。

3. **表示变量可能被未知因素修改**：在某些硬件相关的编程中，比如操作系统的开发或嵌入式系统编程中，某些内存位置可能由硬件事件改变而非软件控制的代码路径。`volatile`声明这些变量可以防止编译器做出不正确的假设和优化。

### 注意事项

- **不是同步机制**：虽然`volatile`可以确保变量读写的可见性，但它本身并不提供互斥或原子性保证。例如，在增加或比较并交换等复合操作中，仅使用`volatile`是不足以防止并发问题的。

- **性能考量**：使用`volatile`会禁止编译器对这些变量进行某些优化，可能会对性能产生一定影响。因此，应当仅在必要时使用`volatile`关键字。

- **有限的使用场景**：随着Java和其他语言中并发编程工具的发展，比如在Java中的`java.util.concurrent`包，`volatile`的使用场景相对减少。这些工具提供了更丰富的同步机制，对于复杂并发控制来说，通常是更好的选择。

总的来说，`volatile`是多线程编程中一个重要的概念，能够帮助开发者在特定场景下安全地共享变量，但它并不能替代完整的同步机制。正确使用`volatile`需要对并发编程的内存模型有深入的理解。

<!-- more -->

## 使用示例

在计算机编程中，`volatile`是一个关键字，它用于告诉编译器一个变量的值可能会被程序之外的因素改变。这意味着使用`volatile`声明的变量每次被访问时都必须直接从内存中读取其值，而不是从寄存器或其他缓存中读取。这保证了变量值的实时性和一致性。

### 确保操作完成的意义

当提到“确保在volatile变量读写操作之前的所有操作都在内存中完成”，这通常指的是在并发编程中，为了维护内存可见性和操作的顺序性，编译器和处理器不会对这些操作进行重排序。重排序是编译器和处理器用来优化程序性能的一种手段，但在多线程环境下，这可能会导致数据不一致的问题。使用`volatile`关键字可以部分避免这种情况，因为它告诉编译器和处理器不要对这些变量的读写操作进行优化，确保在对volatile变量的读写操作之前，所有之前的修改都已经被提交到主存中，从而对其他线程可见。

### 示例解释

考虑一个简单的例子，其中有两个线程：线程A和线程B。线程A负责更新数据，而线程B负责读取数据。

```java
class SharedObject {
    volatile boolean ready = false;
    int number = 0;

    public void writer() { // 线程A执行的方法
        number = 123; // 步骤1
        ready = true; // 步骤2
    }

    public void reader() { // 线程B执行的方法
        if (ready) { // 步骤3
            System.out.println(number); // 步骤4
        }
    }
}
```

在这个例子中，`ready`是一个被声明为`volatile`的变量。这保证了两件事：

1. **顺序性**：在`writer`方法中，任何在写`ready = true;`（步骤2）之前的操作，如`number = 123;`（步骤1），都不会被重排序到写操作之后。这意味着，当`ready`被设置为`true`时，`number`肯定已经被写入到主存中。

2. **可见性**：当线程B检查`ready`变量时（步骤3），如果它读取到`ready`为`true`，那么它也保证能看到线程A在`ready`变为`true`之前对`number`所做的写入（步骤1）。这是因为`ready`变量的读取和写入都直接与主存交互，绕过了缓存和寄存器，从而保证了所有线程都能看到一致的数据。

因此，使用`volatile`关键字可以确保在对这个变量的任何读操作之前，所有之前的写操作都已经完成并且对所有线程可见。这在需要低成本的同步操作时非常有用，尤其是在读多写少的场景中。然而，需要注意的是，`volatile`并不能保证复合操作（如递增操作）的原子性，对于这种情况，仍然需要使用锁或其他同步机制。


