---
title: 内存基础
date: 2023-12-14 19:17:32
tags:
  - go
  - memory
categories:
  - 理论
  - go
---


## 内存的虚拟地址
在现代计算机系统中，虚拟地址是指操作系统为程序提供的地址空间。
- 这种地址空间是由操作系统和CPU的**内存管理单元（Memory Management Unit, MMU）**共同管理的，它与物理内存（RAM）中的实际地址是分开的。
- 虚拟地址为每个程序提供了一种看似连续且独立的内存空间，这使得每个程序都以为自己独占了整个系统的内存。
<!-- more -->

## “页”
在虚拟内存系统中，内存是以“页”为基本单元构成的。页是内存和存储设备之间交换数据的固定长度块，通常大小是4KB或更大（这取决于操作系统和硬件架构）。

操作系统通过“页表”来管理虚拟地址到物理地址的映射关系。

## 虚拟地址和页的作用
1. **内存管理：**
页使得操作系统可以更高效地管理内存。**操作系统可以将不同的虚拟页映射到物理内存中的任何位置，**甚至可以将它们映射到硬盘上的**交换空间（swap space）**，从而实现虚拟内存。

2. **进程隔离：**
每个进程都有自己的虚拟地址空间，其中的地址被映射到物理内存的不同部分。这**保证了一个进程无法直接访问或修改另一个进程的数据**，从而提高了系统的安全性和稳定性。
3. **按需分配：**
操作系统可以根据需要动态地加载和卸载页面。例如，**当程序访问某个尚未加载的内存区域时，操作系统会加载相应的页到物理内存**。同样，**当内存紧张时，操作系统可以将不常用的页移动到硬盘上的交换空间。**

## 虚拟地址和页的总结
虚拟地址是操作系统为程序提供的一种抽象的内存地址，它通过页表映射到物理内存地址。内存的最小单元是“页”，这是操作系统管理内存的基本方式，它允许灵活的内存分配、安全的进程隔离，以及有效的内存使用。虚拟内存系统的这种设计极大地提高了现代计算机系统的效率和灵活性。


## 文件读写过程

当执行传统的文件读写操作时, 一般会有以下几步：

### 系统调用
- 用户空间操作：
当一个应用程序需要读取或写入文件时，它会执行一个系统调用，比如`read()`或`write()`。
- 上下文切换：
执行系统调用意味着会发生从{% post_link go/cpu的工作模式 用户模式 %}到{% post_link go/cpu的工作模式 内核模式 %}的上下文切换。这个过程中，CPU切换到内核模式，开始执行操作系统的代码。


### 内核处理
- 内核空间操作：一旦进入内核模式，操作系统的内核接管控制权。内核首先检查调用参数的有效性，比如文件描述符、内存地址、读写大小等。

### 查找页缓存
- 检查页缓存：
对于读操作，内核会先检查所需数据是否已在`页缓存（Page Cache）`中。如果是，它可以直接从内存中复制数据到用户空间的缓冲区。
- 从磁盘读取：
如果数据不在页缓存中，内核会从文件所在的存储设备（如硬盘）读取数据，并将其存储在页缓存中。

### 数据传输
- 数据复制到用户空间：无论数据来自页缓存还是新的磁盘读取，内核都会将数据复制到用户空间提供的缓冲区中。
- 缓冲区管理：这个复制操作通常是通过`DMA（Direct Memory Access）`或其他有效的内存操作完成的。

### 写操作
- 写入页缓存：对于写操作，内核首先将数据**从用户空间的缓冲区复制到页缓存中**。
- **延迟写入：**实际的磁盘写入可能会被延迟执行。内核可能会等待一段时间或直到有足够的数据要写入磁盘时再执行，以提高效率。


### 完成系统调用
- 返回用户空间：一旦读写操作完成，控制权返回用户空间，系统调用返回。
对于读操作，这意味着用户程序现在可以访问缓冲区中的数据。对于写操作，数据已经被复制到页缓存中，等待最终写入磁盘。

### 错误处理
错误和状态：如果在任何步骤中出现错误（如无效的文件描述符、读写错误等），内核会处理这些错误，并将错误信息返回给用户空间的应用程序。

**总之，**
**在传统的文件读写操作中，数据在用户空间和内核空间之间来回移动。读操作涉及从磁盘到页缓存，再到用户空间的传输，而写操作涉及从用户空间到页缓存，最终可能到磁盘的传输。这个过程涉及系统调用、上下文切换、数据复制和缓冲区管理等多个步骤。这种方法虽然在某些情况下效率不是最优的，但它的通用性和简单性使其成为文件操作的基础。**

## mmap

mmap是一种在Unix-like系统中将文件映射到内存的方法。**它提供了一种高效的文件访问机制，允许程序直接从内存中读写文件，而不是使用传统的读写系统调用。**这样做的好处是可以提高文件操作的性能，**特别是对于大文件的处理。**

当文件被mmap映射到内存后，**操作系统创建了一个内存区域，这个区域的内容直接对应于文件的内容。程序可以像访问普通内存那样访问这个区域，而操作系统会负责将任何修改同步回文件。**这就避免了额外的读写系统调用和数据复制，从而提高效率。

## mmap的优势和特点
### 内存映射：
mmap将文件内容直接映射到进程的地址空间中，应用程序可以像访问内存那样访问文件数据。这减少了传统读写操作中涉及的数据复制步骤。

### 随机访问：
对于需要频繁随机访问的大文件，mmap提供了一种更高效的机制。由于整个文件（或其大部分）被映射到内存中，随机访问变得更快，无需进行系统调用。

### 延迟加载：
mmap映射文件时，并不立即加载整个文件到内存中。只有在访问特定区域时，相应的数据才会被加载。这对处理大文件特别有用，可以避免一次性加载大量数据到内存中。
共享内存：

mmap可以用于创建**多个进程之间的共享内存区域，这对于进程间通信和快速数据交换非常有用。**

## 代码示例

### 普通读写文件
```go
package main

func main() {
	content := []byte("Hello file I/O")

	err := os.WriteFile("example.txt", content, 0644)
	if err != nil {
		panic(err)
	}

	readContent, err := os.ReadFile("example.txt")
	if err != nil {
		panic(err)
	}

	fmt.Println(string(readContent))

}

```

### 使用mmap

```sh
go get github.com/edsrzf/mmap-go
```

```go
package main

import (
    "fmt"
    "os"

    "github.com/edsrzf/mmap-go"
)

func main() {
    // 打开文件
    file, err := os.OpenFile("example.dat", os.O_RDWR|os.O_CREATE, 0644)
    if err != nil {
        panic(err)
    }
    defer file.Close()

    // 使用mmap映射文件
    mmap, err := mmap.Map(file, mmap.RDWR, 0)
    if err != nil {
        panic(err)
    }
    defer mmap.Unmap()

    // 写入数据到映射的内存
    copy(mmap, []byte("Hello mmap!"))

    // 读取数据
    fmt.Println(string(mmap[:10]))
}

```







