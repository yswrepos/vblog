import{_ as n,o as a,c as s,e as t}from"./app-CzTFaVnz.js";const e={},c=t(`<blockquote><p>C 内存分配主要有 malloc、calloc、realoc 三个函数，以下简要介绍</p></blockquote><h2 id="内存分区" tabindex="-1"><a class="header-anchor" href="#内存分区"><span>内存分区</span></a></h2><p>内存里主要有几个划分，用一张表格表示</p><table><thead><tr><th>内存分区</th><th>内容</th><th>权限</th></tr></thead><tbody><tr><td>栈区</td><td>函数中的普通变量</td><td>可读可写</td></tr><tr><td>堆区</td><td>动态申请的内存</td><td>可读可写</td></tr><tr><td>静态变量区</td><td>static 修饰的变量</td><td>可读可写</td></tr><tr><td>数据区</td><td>用于初始化变量的常量</td><td>只读</td></tr><tr><td>代码区</td><td>代码指令</td><td>只读</td></tr></tbody></table><h2 id="malloc、calloc、realoc" tabindex="-1"><a class="header-anchor" href="#malloc、calloc、realoc"><span>malloc、calloc、realoc</span></a></h2><p>C\\C++允许我们使用这三个函数直接操作内存，具体就是对堆（Heap）的操作，那么这几种有哪些不同呢？</p><h3 id="malloc" tabindex="-1"><a class="header-anchor" href="#malloc"><span>malloc</span></a></h3><ul><li>函数原型 <code>void* malloc (size_t size);</code></li><li>头文件 <code>头文件：#include &lt;stdlib.h&gt;</code></li><li>说明 <code>malloc</code>在 Heap 区域分配一块长度为<code>size</code>字节的连续区域并返回该区域的地址，malloc() 函数不能为所分配的空间初始化值，需要使用 memset()，。在程序结束前，需要使用 free() 进行内存释放。</li><li>例子</li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>  <span class="token keyword">int</span> <span class="token operator">*</span>p  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出100</span>
  <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意： memset 只能给 int 类型赋值的范围为 0x00 - 0xff (即 0 - 255)，超过将按位赋值。<a href="/posts/d8689c7b#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%AA%E8%AF%BB">memset 使用介绍&gt;&gt;</a></p></blockquote><h3 id="calloc" tabindex="-1"><a class="header-anchor" href="#calloc"><span>calloc</span></a></h3><ul><li>函数原型 <code>void* calloc (size_t num, size_t size)</code></li><li>头文件 <code>#include &lt;stdlib.h&gt;</code></li><li>说明 <code>calloc</code>和<code>malloc</code>类似，在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。</li><li>使用</li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 分配100个字节的内存空间</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>注意 由于返回的指针类型未知，所以在使用 calloc() 时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型。</p></blockquote><ul><li>比较 以下两种使用等效</li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token operator">*</span>str1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// malloc() 分配内存空间并用 memset() 初始化</span>
<span class="token keyword">char</span> <span class="token operator">*</span>str2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>str2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="realoc" tabindex="-1"><a class="header-anchor" href="#realoc"><span>realoc</span></a></h3><ul><li>函数原型 <code>void* realloc (void* ptr, size_t size)</code></li><li>头文件 <code>#include &lt;stdlib.h&gt;</code></li><li>说明 ptr 为需要重新分配的内存空间指针，size 为新的内存空间的大小，<code>relloc</code>为指定内存指针的动态内存（通常指 malloc 和 calloc 分配的）重新分配大小。</li><li>注意</li></ul><ol><li>如果 ptr 为 NULL，它的效果和 malloc() 相同，即分配 size 字节的内存空间。</li><li>如果 size 的值为 0，那么 ptr 指向的内存空间就会被释放，但是由于没有开辟新的内存空间，所以会返回空指针，类似于调用 free()。</li><li>指针 ptr 必须是在动态内存空间分配成功的指针，形如如下的指针是不可以的：int *i; int a[2]；会导致运行时错误，可以简单的这样记忆：用 malloc()、calloc()、realloc() 分配成功的指针才能被 realloc() 函数接受。</li><li>成功分配内存后 ptr 将被系统回收，不可再对 ptr 指针做任何操作，包括 free()。相反的，可以对 realloc() 函数的返回值进行正常操作。</li><li>如果是扩大内存操作会把 ptr 指向的内存中的数据复制到新地址（新地址也可能会和原地址相同，但依旧不能对原指针进行任何操作）；如果是缩小内存操作，原始据会被复制并截取新长度。</li></ol><ul><li>返回值 分配成功返回新的内存地址，可能与 ptr 相同，也可能不同。失败则返回 NULL。</li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">5</span></span></span>
  <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span>SIZE<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>rp<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 扩容为之前的两倍</span>
  <span class="token comment">// 注意这里使用了新指针(rp)而不是(p)，可在realloc分配失败时，防止p指向的内存泄漏</span>
  rp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">free</span><span class="token punctuation">(</span>rp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li><code>malloc</code> 和 <code>colloc</code> 都是动态分配内存，但colloc会在初始化的同时将每个字节的内存值初始化为0。</li><li><code>realoc</code> 主要功能是对 <code>malloc</code> 和 <code>colloc</code> 分配的内存容量进行调整。</li></ul>`,23),o=[c];function l(p,i){return a(),s("div",null,o)}const d=n(e,[["render",l],["__file","C内存分配.html.vue"]]),u=JSON.parse('{"path":"/posts/c/C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html","title":"C内存分配","lang":"zh-CN","frontmatter":{"title":"C内存分配","toc":true,"keywords":"nodejs,GC","tags":"c/c++ 内存","categories":["c/c++"],"abbrlink":"a1501c1d","date":"2020-09-17T19:13:16.000Z"},"headers":[{"level":2,"title":"内存分区","slug":"内存分区","link":"#内存分区","children":[]},{"level":2,"title":"malloc、calloc、realoc","slug":"malloc、calloc、realoc","link":"#malloc、calloc、realoc","children":[{"level":3,"title":"malloc","slug":"malloc","link":"#malloc","children":[]},{"level":3,"title":"calloc","slug":"calloc","link":"#calloc","children":[]},{"level":3,"title":"realoc","slug":"realoc","link":"#realoc","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1712251162000,"contributors":[{"name":"yushen","email":"85443289+yushenw@users.noreply.github.com","commits":1}]},"filePathRelative":"posts/c/C内存分配.md","excerpt":"<blockquote>\\n<p>C 内存分配主要有 malloc、calloc、realoc 三个函数，以下简要介绍</p>\\n</blockquote>\\n<h2>内存分区</h2>\\n<p>内存里主要有几个划分，用一张表格表示</p>\\n<table>\\n<thead>\\n<tr>\\n<th>内存分区</th>\\n<th>内容</th>\\n<th>权限</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>栈区</td>\\n<td>函数中的普通变量</td>\\n<td>可读可写</td>\\n</tr>\\n<tr>\\n<td>堆区</td>\\n<td>动态申请的内存</td>\\n<td>可读可写</td>\\n</tr>\\n<tr>\\n<td>静态变量区</td>\\n<td>static 修饰的变量</td>\\n<td>可读可写</td>\\n</tr>\\n<tr>\\n<td>数据区</td>\\n<td>用于初始化变量的常量</td>\\n<td>只读</td>\\n</tr>\\n<tr>\\n<td>代码区</td>\\n<td>代码指令</td>\\n<td>只读</td>\\n</tr>\\n</tbody>\\n</table>\\n"}');export{d as comp,u as data};
