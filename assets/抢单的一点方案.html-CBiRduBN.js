import{_ as n,o as e,c as s,e as a}from"./app-CzTFaVnz.js";const l={},t=a(`<p>在使用消息队列（如RabbitMQ）处理类似于外卖应用中的抢单功能时，确保只有一个骑手能成功抢单，而其他骑手则无法抢单，是一个典型的竞争条件问题。以下是一种可能的解决方案，使用消息队列来实现这一需求：</p><h3 id="_1-使用单一消费者模式" tabindex="-1"><a class="header-anchor" href="#_1-使用单一消费者模式"><span>1. 使用单一消费者模式</span></a></h3><p>一种方法是确保只有一个消费者（骑手）能够接收到订单消息。但这种方法并不适用于本场景，因为我们希望所有骑手都有平等的机会去抢单。</p><h3 id="_2-发布订单到所有骑手-但仅允许第一个响应的骑手获得订单" tabindex="-1"><a class="header-anchor" href="#_2-发布订单到所有骑手-但仅允许第一个响应的骑手获得订单"><span>2. 发布订单到所有骑手，但仅允许第一个响应的骑手获得订单</span></a></h3><p>更合适的方法是：</p><ul><li><p><strong>发布订单消息</strong>：当一个订单产生时，通过消息队列广播这个订单给所有附近的骑手。这可以通过发布/订阅模式实现，其中每个骑手都订阅了某个特定的订单通知主题。</p></li><li><p><strong>骑手响应</strong>：骑手收到订单消息后，尝试通过另一个API接口抢单。这个抢单的API需要设计成幂等的，并且能够处理并发请求，确保只有第一个成功的骑手能抢到订单。</p></li><li><p><strong>处理并发</strong>：在抢单API接口中，使用数据库的唯一约束、事务、乐观锁或悲观锁等机制来保证即便多个骑手几乎同时响应，也只能有一个骑手成功处理订单。一旦订单被某个骑手成功接单，订单的状态就会更新，后续的抢单尝试将因为订单状态已变更而失败。</p></li></ul><h3 id="实现细节" tabindex="-1"><a class="header-anchor" href="#实现细节"><span>实现细节：</span></a></h3><ul><li><p><strong>订单状态管理</strong>：在数据库中为订单设计一个状态字段，初始状态是“待接单”。当骑手尝试接单时，API首先检查订单状态，只有当状态仍然是“待接单”时，才允许进一步的处理。</p></li><li><p><strong>乐观锁</strong>：可以为订单表增加一个版本号字段。骑手尝试接单时，提交当前的版本号。如果版本号匹配，则接单成功，并且版本号加一。如果不匹配，表示其他骑手已经成功接单，当前尝试失败。</p></li><li><p><strong>悲观锁</strong>：在处理接单请求时，通过在数据库上对订单行加锁（例如，使用<code>SELECT FOR UPDATE</code>语句）来避免并发修改。</p></li></ul><h3 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化：</span></a></h3><ul><li><p><strong>限制响应者数量</strong>：为了减少无谓的竞争和系统负载，可以通过算法或业务逻辑预先筛选出一定数量的骑手进行通知，而不是广播给所有骑手。</p></li><li><p><strong>消息确认与死信队列</strong>：确保消息一旦被成功消费（即有骑手成功接单），就从消息队列中确认删除。如果订单长时间无人接单，可以通过死信队列处理超时订单，重新进入抢单流程或进行其他处理。</p></li></ul><p>通过上述机制，即使有200个骑手同时尝试抢单，也可以保证系统的一致性和公平性，同时保证只有一个骑手能成功接单。</p><h3 id="乐观锁如何保证原子性" tabindex="-1"><a class="header-anchor" href="#乐观锁如何保证原子性"><span>乐观锁如何保证原子性</span></a></h3><p>关于乐观锁如何在并发场景下确保数据的一致性和原子性。乐观锁确实依赖于版本号（或时间戳）机制来解决并发控制，但关键在于如何在更新操作中正确使用乐观锁来保证操作的原子性。</p><p>乐观锁的基本思想是“先做操作，后检查是否有冲突”，并且在检查和实际更新之间不加锁。这种方式在并发不是特别高的场景下效率较高，但它的确存在你所提到的问题：在高并发情况下，多个事务可能同时认为自己可以进行更新。</p><h3 id="如何保证原子性" tabindex="-1"><a class="header-anchor" href="#如何保证原子性"><span>如何保证原子性</span></a></h3><p>为了保证更新操作的原子性，乐观锁通常和数据库的事务机制结合使用。在更新操作时，会在<code>WHERE</code>子句中加入版本号的检查。更新语句大致如下：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> order_table <span class="token keyword">SET</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> version <span class="token operator">=</span> version <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">WHERE</span> order_id <span class="token operator">=</span> ? <span class="token operator">AND</span> version <span class="token operator">=</span> ?
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里的<code>version = ?</code>是检查条件，确保在这个事务读取数据之后，版本号没有被其他事务更新。如果版本号已经被其他事务更新（即当前事务中的版本号已经过时），当前的<code>UPDATE</code>语句将不会更新任何行（因为<code>WHERE</code>条件不成立），这时数据库会返回更新了0行数据的结果。</p><h3 id="处理并发更新" tabindex="-1"><a class="header-anchor" href="#处理并发更新"><span>处理并发更新</span></a></h3><ul><li><strong>事务提交前的最后检查</strong>：上述<code>UPDATE</code>语句实质上是在事务提交前对版本号进行最后的检查，如果在这个事务读取数据后有其他事务已经修改了数据并提交，当前事务的版本号检查将失败，从而阻止了数据的更新。</li><li><strong>事务失败处理</strong>：应用程序需要检查<code>UPDATE</code>操作的结果，如果发现没有更新任何行（即返回结果为0），则意味着存在并发冲突。这时，应用程序可以选择重试整个操作，或者根据业务需求进行其他处理。</li></ul><p>通过这种机制，即使多个事务几乎同时到达并尝试更新同一条记录，也只有第一个完成<code>UPDATE</code>操作（满足版本号检查条件）的事务能够成功更新数据，其他后续的事务都会在版本号检查时失败，因此需要重新读取数据，重新尝试操作或者放弃。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>乐观锁通过版本号加上数据库的事务机制来实现并发控制，保证了即使在高并发环境下也能维护数据的一致性和原子性。关键在于，任何更新操作都必须基于最新的数据版本进行，否则更新将失败。这种机制减少了锁的使用，提高了系统的并发能力，但在冲突频繁的环境中可能会导致较高的重试率。</p>`,23),o=[t];function p(r,i){return e(),s("div",null,o)}const d=n(l,[["render",p],["__file","抢单的一点方案.html.vue"]]),h=JSON.parse('{"path":"/posts/theory/%E6%8A%A2%E5%8D%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%96%B9%E6%A1%88.html","title":"抢单的一点方案","lang":"zh-CN","frontmatter":{"title":"抢单的一点方案","date":"2024-02-25T01:26:25.000Z","tags":["分布式","高并发"],"categories":["theory"]},"headers":[{"level":3,"title":"1. 使用单一消费者模式","slug":"_1-使用单一消费者模式","link":"#_1-使用单一消费者模式","children":[]},{"level":3,"title":"2. 发布订单到所有骑手，但仅允许第一个响应的骑手获得订单","slug":"_2-发布订单到所有骑手-但仅允许第一个响应的骑手获得订单","link":"#_2-发布订单到所有骑手-但仅允许第一个响应的骑手获得订单","children":[]},{"level":3,"title":"实现细节：","slug":"实现细节","link":"#实现细节","children":[]},{"level":3,"title":"优化：","slug":"优化","link":"#优化","children":[]},{"level":3,"title":"乐观锁如何保证原子性","slug":"乐观锁如何保证原子性","link":"#乐观锁如何保证原子性","children":[]},{"level":3,"title":"如何保证原子性","slug":"如何保证原子性","link":"#如何保证原子性","children":[]},{"level":3,"title":"处理并发更新","slug":"处理并发更新","link":"#处理并发更新","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1712251162000,"contributors":[{"name":"yushen","email":"85443289+yushenw@users.noreply.github.com","commits":1}]},"filePathRelative":"posts/theory/抢单的一点方案.md","excerpt":"<p>在使用消息队列（如RabbitMQ）处理类似于外卖应用中的抢单功能时，确保只有一个骑手能成功抢单，而其他骑手则无法抢单，是一个典型的竞争条件问题。以下是一种可能的解决方案，使用消息队列来实现这一需求：</p>\\n<h3>1. 使用单一消费者模式</h3>\\n<p>一种方法是确保只有一个消费者（骑手）能够接收到订单消息。但这种方法并不适用于本场景，因为我们希望所有骑手都有平等的机会去抢单。</p>\\n<h3>2. 发布订单到所有骑手，但仅允许第一个响应的骑手获得订单</h3>\\n<p>更合适的方法是：</p>\\n<ul>\\n<li>\\n<p><strong>发布订单消息</strong>：当一个订单产生时，通过消息队列广播这个订单给所有附近的骑手。这可以通过发布/订阅模式实现，其中每个骑手都订阅了某个特定的订单通知主题。</p>\\n</li>\\n<li>\\n<p><strong>骑手响应</strong>：骑手收到订单消息后，尝试通过另一个API接口抢单。这个抢单的API需要设计成幂等的，并且能够处理并发请求，确保只有第一个成功的骑手能抢到订单。</p>\\n</li>\\n<li>\\n<p><strong>处理并发</strong>：在抢单API接口中，使用数据库的唯一约束、事务、乐观锁或悲观锁等机制来保证即便多个骑手几乎同时响应，也只能有一个骑手成功处理订单。一旦订单被某个骑手成功接单，订单的状态就会更新，后续的抢单尝试将因为订单状态已变更而失败。</p>\\n</li>\\n</ul>\\n<h3>实现细节：</h3>\\n<ul>\\n<li>\\n<p><strong>订单状态管理</strong>：在数据库中为订单设计一个状态字段，初始状态是“待接单”。当骑手尝试接单时，API首先检查订单状态，只有当状态仍然是“待接单”时，才允许进一步的处理。</p>\\n</li>\\n<li>\\n<p><strong>乐观锁</strong>：可以为订单表增加一个版本号字段。骑手尝试接单时，提交当前的版本号。如果版本号匹配，则接单成功，并且版本号加一。如果不匹配，表示其他骑手已经成功接单，当前尝试失败。</p>\\n</li>\\n<li>\\n<p><strong>悲观锁</strong>：在处理接单请求时，通过在数据库上对订单行加锁（例如，使用<code>SELECT FOR UPDATE</code>语句）来避免并发修改。</p>\\n</li>\\n</ul>\\n"}');export{d as comp,h as data};
