import{_ as s,r as e,o as t,c as o,a as p,b as n,d as c,w as d,e as l}from"./app-Du_kiChf.js";const i={},u=l(`<h2 id="基本介绍" tabindex="-1"><a class="header-anchor" href="#基本介绍"><span>基本介绍</span></a></h2><p><code>pickle.loads()</code> 是 Python 中用于从字节流中加载序列化对象的函数。<code>pickle</code> 是 Python 中的一种序列化模块，它能够将 Python 对象转换为字节流（即序列化），并在需要时将其重新加载为 Python 对象（即反序列化）。<code>loads()</code> 函数是 <code>pickle</code> 模块中用于反序列化操作的函数，它接受一个包含序列化对象的字节流，并返回相应的 Python 对象。</p><p>以下是一个简单的示例，演示如何使用 <code>pickle.loads()</code> 来反序列化一个对象：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">import</span> pickle

<span class="token comment"># 定义一个字典对象</span>
data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&#39;name&#39;</span><span class="token punctuation">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;age&#39;</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">&#39;city&#39;</span><span class="token punctuation">:</span> <span class="token string">&#39;New York&#39;</span><span class="token punctuation">}</span>

<span class="token comment"># 将对象序列化为字节流</span>
serialized_data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">)</span>

<span class="token comment"># 从字节流中加载对象</span>
loaded_data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>serialized_data<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>loaded_data<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们首先将一个字典对象 <code>data</code> 序列化为字节流 <code>serialized_data</code>，然后使用 <code>pickle.loads()</code> 函数从字节流中加载对象，并将其赋值给 <code>loaded_data</code>。最后，我们打印 <code>loaded_data</code>，结果应该与原始的 <code>data</code> 对象相同。</p><h2 id="场景和使用" tabindex="-1"><a class="header-anchor" href="#场景和使用"><span>场景和使用</span></a></h2>`,6);function r(k,h){const a=e("RouteLink");return t(),o("div",null,[u,p("p",null,[n("序列化和反序列化可用于跨语言通信。 这是"),c(a,{to:"/2024/02/28/go/go%20encoding%20glob%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%AE%9E%E4%BE%8B/"},{default:d(()=>[n("一个例子")]),_:1})])])}const _=s(i,[["render",r],["__file","python反序列化字节流.html.vue"]]),y=JSON.parse(`{"path":"/posts/python/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E8%8A%82%E6%B5%81.html","title":"python反序列化字节流","lang":"zh-CN","frontmatter":{"title":"python反序列化字节流","date":"2024-03-01T10:35:37.000Z","tags":["python","序列化"],"categories":"python"},"headers":[{"level":2,"title":"基本介绍","slug":"基本介绍","link":"#基本介绍","children":[]},{"level":2,"title":"场景和使用","slug":"场景和使用","link":"#场景和使用","children":[]}],"git":{"updatedTime":1712251162000,"contributors":[{"name":"yushen","email":"85443289+yushenw@users.noreply.github.com","commits":1}]},"filePathRelative":"posts/python/python反序列化字节流.md","excerpt":"<h2>基本介绍</h2>\\n<p><code>pickle.loads()</code> 是 Python 中用于从字节流中加载序列化对象的函数。<code>pickle</code> 是 Python 中的一种序列化模块，它能够将 Python 对象转换为字节流（即序列化），并在需要时将其重新加载为 Python 对象（即反序列化）。<code>loads()</code> 函数是 <code>pickle</code> 模块中用于反序列化操作的函数，它接受一个包含序列化对象的字节流，并返回相应的 Python 对象。</p>\\n<p>以下是一个简单的示例，演示如何使用 <code>pickle.loads()</code> 来反序列化一个对象：</p>\\n<div class=\\"language-python\\" data-ext=\\"py\\" data-title=\\"py\\"><pre class=\\"language-python\\"><code><span class=\\"token keyword\\">import</span> pickle\\n\\n<span class=\\"token comment\\"># 定义一个字典对象</span>\\ndata <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">{</span><span class=\\"token string\\">'name'</span><span class=\\"token punctuation\\">:</span> <span class=\\"token string\\">'John'</span><span class=\\"token punctuation\\">,</span> <span class=\\"token string\\">'age'</span><span class=\\"token punctuation\\">:</span> <span class=\\"token number\\">30</span><span class=\\"token punctuation\\">,</span> <span class=\\"token string\\">'city'</span><span class=\\"token punctuation\\">:</span> <span class=\\"token string\\">'New York'</span><span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token comment\\"># 将对象序列化为字节流</span>\\nserialized_data <span class=\\"token operator\\">=</span> pickle<span class=\\"token punctuation\\">.</span>dumps<span class=\\"token punctuation\\">(</span>data<span class=\\"token punctuation\\">)</span>\\n\\n<span class=\\"token comment\\"># 从字节流中加载对象</span>\\nloaded_data <span class=\\"token operator\\">=</span> pickle<span class=\\"token punctuation\\">.</span>loads<span class=\\"token punctuation\\">(</span>serialized_data<span class=\\"token punctuation\\">)</span>\\n\\n<span class=\\"token keyword\\">print</span><span class=\\"token punctuation\\">(</span>loaded_data<span class=\\"token punctuation\\">)</span>\\n</code></pre></div><p>在这个示例中，我们首先将一个字典对象 <code>data</code> 序列化为字节流 <code>serialized_data</code>，然后使用 <code>pickle.loads()</code> 函数从字节流中加载对象，并将其赋值给 <code>loaded_data</code>。最后，我们打印 <code>loaded_data</code>，结果应该与原始的 <code>data</code> 对象相同。</p>\\n"}`);export{_ as comp,y as data};
