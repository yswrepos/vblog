import{_ as n,o as s,c as a,e}from"./app-BLeSCfhf.js";const t={},o=e(`<p>在 Go 语言中，<code>new</code> 和 <code>make</code> 都是用来分配内存的，但它们用于不同类型并且行为有所不同。</p><h3 id="new" tabindex="-1"><a class="header-anchor" href="#new"><span>new</span></a></h3><ul><li><code>new(T)</code> 用于创建一个 T 类型的新项，并返回指向它的指针（<code>*T</code>）。</li><li><strong>分配的是零值。对于结构体，意味着每个字段都被初始化为其类型的零值。</strong></li><li>适用于<strong>所有类型</strong>，包括基本类型（如 int、float）、复合类型（如 array、struct）、指针、接口等。</li></ul><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code>str <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// 分配一个字符串，初始化为零值 &quot;&quot;，返回 *string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="make" tabindex="-1"><a class="header-anchor" href="#make"><span>make</span></a></h3><ul><li><code>make</code> 仅用于创建<code>切片（slice）</code>、<code>映射（map</code>）和<code>通道（channel）</code>这三种内建的引用类型。</li><li>它不仅分配内存，还<strong>初始化这些类型的内部数据结构</strong>，比如切片的长度和容量、映射的哈希表等。</li><li><strong>返回的是初始化后的（非零）值，而不是指针。</strong></li></ul><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code>sli <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个长度为 10，容量为 15 的切片，返回 []int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h3><ul><li><strong>本质</strong>：<code>new</code> 返回指针，<code>make</code> 返回初始化的值。</li><li><strong>使用类型</strong>：<code>new</code> 可用于所有类型，<code>make</code> 仅用于切片、映射和通道。</li><li><strong>行为</strong>：<code>new</code> 分配内存并初始化为零值，<code>make</code> 分配并初始化特定类型的内部结构。</li></ul><h3 id="选择使用哪一个" tabindex="-1"><a class="header-anchor" href="#选择使用哪一个"><span>选择使用哪一个</span></a></h3><ul><li>当您需要分配一个零值变量并获得指向它的指针时，使用 <code>new</code>。</li><li>当您需要初始化一个切片、映射或通道时，使用 <code>make</code>。</li></ul><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">var</span> p <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>       <span class="token comment">// 分配切片本身（指针），但切片指向的数组为 nil</span>
<span class="token keyword">var</span> v  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 切片 v 引用了一个具有 100 个 int 的新数组</span>

<span class="token comment">// 假设你要分配一个结构体并获得一个指向它的指针</span>
<span class="token keyword">type</span> MyStruct <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    A <span class="token builtin">int</span>
    B <span class="token builtin">string</span>
<span class="token punctuation">}</span>
ms <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>MyStruct<span class="token punctuation">)</span> <span class="token comment">// ms 是一个指向新分配的结构体的指针，其字段被初始化为零值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，<code>ms</code> 指向一个 <code>MyStruct</code> 类型的新实例，而 <code>p</code> 是一个指向 <code>nil</code> 切片的指针，<code>v</code> 是一个具有 100 个 int 的切片。</p><h2 id="切片本身指针的作用" tabindex="-1"><a class="header-anchor" href="#切片本身指针的作用"><span>切片本身指针的作用</span></a></h2><h3 id="修改切片本身" tabindex="-1"><a class="header-anchor" href="#修改切片本身"><span>修改切片本身</span></a></h3><p>在 Go 中，<code>var p *[]int = new([]int)</code> 创建了一个指向切片的指针，其中该切片的初始值为 <code>nil</code>。 当您想在函数内部修改切片本身（即改变切片头的指针、长度和容量），而不仅仅是修改切片的内容时，您可能会用到指向切片的指针。例如：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">modifySlice</span><span class="token punctuation">(</span>s <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 修改 s 指向的切片本身</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> p <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// p 是一个指向 nil 切片的指针</span>
    <span class="token function">modifySlice</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token comment">// 输出: [100]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>modifySlice</code> 函数接受一个指向切片的指针，并修改了这个切片本身。这是因为切片是引用类型，但切片本身的更改（如通过 <code>append</code> 扩容）并不会反映回原来的切片变量，除非通过指针操作。</p><h3 id="json反序列化" tabindex="-1"><a class="header-anchor" href="#json反序列化"><span>JSON反序列化</span></a></h3><p>在处理 JSON 反序列化时，有时可能会用到指向切片的指针，特别是<strong>需要区分空切片和未设置的切片时：</strong></p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> Response <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Data <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token string">\`json:&quot;data&quot;\`</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    jsonStr <span class="token operator">:=</span> <span class="token string">\`{&quot;data&quot;: [1, 2, 3]}\`</span>
    resp <span class="token operator">:=</span> Response<span class="token punctuation">{</span><span class="token punctuation">}</span>
    json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>resp<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>Data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 输出: [1 2 3]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这种情况下，<code>Data</code> 字段作为一个指向切片的指针，可以区分 <code>data</code> 字段未出现在 JSON 中（<code>Data</code> 为 <code>nil</code>）和 <code>data</code> 字段为空数组（<code>Data</code> 指向一个空切片）的情况</p><h2 id="go中数据结构常用定义和使用的区别" tabindex="-1"><a class="header-anchor" href="#go中数据结构常用定义和使用的区别"><span>GO中数据结构常用定义和使用的区别</span></a></h2><h3 id="append操作" tabindex="-1"><a class="header-anchor" href="#append操作"><span>append操作</span></a></h3><p>使用 append 向切片添加元素时，如果切片的底层数组还有足够的容量来容纳新元素，append 会在切片的末尾添加这个元素。如果容量不足以容纳新元素，append 会创建一个新的、更大的数组，将现有元素和新元素复制到这个新数组中，然后返回这个新数组的切片。</p><ul><li>使用make <strong>这会创建一个长度和容量都为0的空切片，而不是nil切片，它已经有了一个底层数组，只是这个数组的长度是 0。</strong></li></ul><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code>s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用new <strong>这里的切片相当于零值, 数组指针为nil</strong></li></ul><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code>s1 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
s1 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>只声明 <strong>这里的切片相当于一个零值的（nil）切片，指针也指向nil, 当append操作后才会为其分配底层数组</strong>， 与上面的区别主要是内存分配位置（栈和堆）不同和返回类型不同</li></ul><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">var</span> s2 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
s2 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际编程中，var s []int 由于其简洁性通常是首选方法，特别是当您不需要立即指定切片的初始容量时。使用 make([]int, 0) 对于需要明确指出切片已经被初始化但当前为空的情况比较有用，而 new([]int) 在需要切片指针的情况下使用。</p><h2 id="string-builder中-var-vs-new" tabindex="-1"><a class="header-anchor" href="#string-builder中-var-vs-new"><span>string.Builder中 var vs new</span></a></h2><p>一般来说，选择 <code>var builder strings.Builder</code> 还是 <code>builder := new(strings.Builder)</code> 主要取决于具体需求和上下文，但从内存效率的角度来看，它们有些差异。</p><h3 id="var-builder-strings-builder" tabindex="-1"><a class="header-anchor" href="#var-builder-strings-builder"><span>var builder strings.Builder</span></a></h3><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">var</span> builder strings<span class="token punctuation">.</span>Builder
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用 <code>var</code> 声明的 <code>builder</code> 会在栈上分配内存。栈上的内存分配和回收通常比堆上的操作更快，因为栈是线性分配的，且生命周期通常由编译器自动管理。**对于栈上的局部变量，一旦它们超出作用域，相关内存会被立即回收。**因此，如果 <code>builder</code> 是一个局部变量，不需要跨多个函数使用，那么使用 <code>var</code> 声明通常是一个好的选择。</p><h3 id="builder-new-strings-builder" tabindex="-1"><a class="header-anchor" href="#builder-new-strings-builder"><span>builder := new(strings.Builder)</span></a></h3><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code>builder <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span>Builder<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用 <code>new</code> 函数创建的 <code>builder</code> 是一个指向 <code>strings.Builder</code> 的指针，指针本身在栈上分配，但它指向的 <code>strings.Builder</code> 实例在堆上分配。堆上的内存分配可能比栈上的分配稍慢，且需要通过垃圾回收器来管理。如果您需要在多个函数间共享 <code>builder</code> 或者作为返回值传递 <code>builder</code>，使用 <code>new</code> 可以更方便地实现。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>如果 <code>builder</code> 只在一个函数内部使用，且没有跨函数传递的需求，<code>var builder strings.Builder</code> 通常是更高效的选择。</li><li>如果 <code>builder</code> 需要在多个函数间共享或作为函数返回值，<code>builder := new(strings.Builder)</code> 可以提供更多的灵活性。</li></ul><p>在实际编程中，<code>strings.Builder</code> 通常不涉及大量的数据或复杂的生命周期管理，所以这两种方式在性能上的差异通常是微不足道的。选择哪一种更多地取决于代码风格和具体场景。对于 <code>strings.Builder</code> 这样的小型结构，优先考虑代码的可读性和简洁性通常是个不错的选择</p>`,44),p=[o];function i(l,c){return s(),a("div",null,p)}const u=n(t,[["render",i],["__file","go new和make的区别.html.vue"]]),r=JSON.parse('{"path":"/posts/go/go%20new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"go new和make的区别","lang":"zh-CN","frontmatter":{"layout":"posts","title":"go new和make的区别","date":"2024-01-23T16:49:49.000Z","categories":["go"],"tags":["go"]},"headers":[{"level":3,"title":"new","slug":"new","link":"#new","children":[]},{"level":3,"title":"make","slug":"make","link":"#make","children":[]},{"level":3,"title":"区别","slug":"区别","link":"#区别","children":[]},{"level":3,"title":"选择使用哪一个","slug":"选择使用哪一个","link":"#选择使用哪一个","children":[]},{"level":3,"title":"示例","slug":"示例","link":"#示例","children":[]},{"level":2,"title":"切片本身指针的作用","slug":"切片本身指针的作用","link":"#切片本身指针的作用","children":[{"level":3,"title":"修改切片本身","slug":"修改切片本身","link":"#修改切片本身","children":[]},{"level":3,"title":"JSON反序列化","slug":"json反序列化","link":"#json反序列化","children":[]}]},{"level":2,"title":"GO中数据结构常用定义和使用的区别","slug":"go中数据结构常用定义和使用的区别","link":"#go中数据结构常用定义和使用的区别","children":[{"level":3,"title":"append操作","slug":"append操作","link":"#append操作","children":[]}]},{"level":2,"title":"string.Builder中 var vs new","slug":"string-builder中-var-vs-new","link":"#string-builder中-var-vs-new","children":[{"level":3,"title":"var builder strings.Builder","slug":"var-builder-strings-builder","link":"#var-builder-strings-builder","children":[]},{"level":3,"title":"builder := new(strings.Builder)","slug":"builder-new-strings-builder","link":"#builder-new-strings-builder","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"updatedTime":1712251162000,"contributors":[{"name":"yushen","email":"85443289+yushenw@users.noreply.github.com","commits":1}]},"filePathRelative":"posts/go/go new和make的区别.md","excerpt":"<p>在 Go 语言中，<code>new</code> 和 <code>make</code> 都是用来分配内存的，但它们用于不同类型并且行为有所不同。</p>\\n<h3>new</h3>\\n<ul>\\n<li><code>new(T)</code> 用于创建一个 T 类型的新项，并返回指向它的指针（<code>*T</code>）。</li>\\n<li><strong>分配的是零值。对于结构体，意味着每个字段都被初始化为其类型的零值。</strong></li>\\n<li>适用于<strong>所有类型</strong>，包括基本类型（如 int、float）、复合类型（如 array、struct）、指针、接口等。</li>\\n</ul>\\n<div class=\\"language-go\\" data-ext=\\"go\\" data-title=\\"go\\"><pre class=\\"language-go\\"><code>str <span class=\\"token operator\\">:=</span> <span class=\\"token function\\">new</span><span class=\\"token punctuation\\">(</span><span class=\\"token builtin\\">string</span><span class=\\"token punctuation\\">)</span> <span class=\\"token comment\\">// 分配一个字符串，初始化为零值 \\"\\"，返回 *string</span>\\n</code></pre></div>"}');export{u as comp,r as data};
