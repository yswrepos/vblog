import{_ as t,r as c,o as p,c as o,a,b as n,d as e,e as l}from"./app-CinGCuEv.js";const i={},r=l(`<h2 id="导读" tabindex="-1"><a class="header-anchor" href="#导读"><span>导读</span></a></h2><p>最近在看Java的过程中对形如<code>public &lt;T&gt; T get(...)</code>的写法感到困惑，在网上很难找到合理解释。</p><h2 id="分析" tabindex="-1"><a class="header-anchor" href="#分析"><span>分析</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">readObjectData</span><span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span> buffer<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">)</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在上面这个方法中 <code>&lt;T&gt;</code>代表声明了一个 通用的泛型参数<code>T</code><code>T</code>作为一个实际的占位符，代表返回值为<code>T</code>类型，实际返回类型只会在使用<code>非泛型</code>类型参数调用时才会确定。 如果这里不定义<code>&lt;T&gt;</code>,那么编译器将认为类型<code>T</code>不存在。 举例来说： 如果你传递<code>Class&lt;String&gt;</code>类型则返回的就是<code>String类型</code>、传递<code>Class&lt;Double&gt;</code>则返回<code>Dubbo</code>类型：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> obj1 <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">readObjectData</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MyClass</span> obj2 <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">readObjectData</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展"><span>扩展</span></a></h2><p>大多数初学者有这样的疑惑，估计是还有以下这种类似让人迷惑的写法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
   <span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">return</span>  a<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样写因为在类上已经定义了<code>&lt;T&gt;</code>泛型参数，所以无需重复定义，如果你这样写：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
   <span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">return</span>  a<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么<code>myMethod</code>将返回的泛型类型可能不与<code>MyClass</code>相同，实际上像以下这样定义可能更加清晰：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token generics"><span class="token punctuation">&lt;</span>T1<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
   <span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span>T2<span class="token punctuation">&gt;</span></span> <span class="token class-name">T2</span> <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token class-name">T2</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">return</span>  a<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>`,14),u={href:"https://stackoverflow.com/questions/15888551/how-to-interpret-public-t-t-readobjectdata-classt-type-in-java",target:"_blank",rel:"noopener noreferrer"},d={href:"https://docs.oracle.com/javase/tutorial/extra/generics/literals.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://stackoverflow.com/questions/6503942/how-to-interpret-java-generics-like-t-t-t-v-queryt-classt",target:"_blank",rel:"noopener noreferrer"},v={href:"https://stackoverflow.com/questions/36363078/what-does-t-t-get-mean-and-is-it-useful",target:"_blank",rel:"noopener noreferrer"};function m(T,g){const s=c("ExternalLinkIcon");return p(),o("div",null,[r,a("p",null,[a("a",u,[n('How to interpret "public <T> T" in Java'),e(s)]),a("a",d,[n("Class Literals as Runtime-Type Tokens"),e(s)]),a("a",k,[n("How to interpret Java generics like <T> T , <T,V> Query<T> , Class<T>?"),e(s)]),a("a",v,[n('What does "<T> T get()" mean?'),e(s)])])])}const b=t(i,[["render",m],["__file","T_ T 和 T的区别.html.vue"]]),y=JSON.parse('{"path":"/posts/java/T_%20T%20%E5%92%8C%20T%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"Java <T> T 和 T的区别","lang":"zh-CN","frontmatter":{"title":"Java <T> T 和 T的区别","toc":true,"keywords":"java <T>,java <T> T和T区别,java泛型","tags":["java","泛型"],"categories":["后端","java"],"abbrlink":"2cc6c3c4","date":"2021-09-30T13:01:16.000Z","description":"导读 最近在看Java的过程中对形如public <T> T get(...)的写法感到困惑，在网上很难找到合理解释。 分析 在上面这个方法中 <T>代表声明了一个 通用的泛型参数T T作为一个实际的占位符，代表返回值为T类型，实际返回类型只会在使用非泛型类型参数调用时才会确定。 如果这里不定义<T>,那么编译器将认为类型T不存在。 举例来说： 如果你...","head":[["meta",{"property":"og:url","content":"https://b.yongzhenxin.com/posts/java/T_%20T%20%E5%92%8C%20T%E7%9A%84%E5%8C%BA%E5%88%AB.html"}],["meta",{"property":"og:site_name","content":"Yunshenw"}],["meta",{"property":"og:title","content":"Java <T> T 和 T的区别"}],["meta",{"property":"og:description","content":"导读 最近在看Java的过程中对形如public <T> T get(...)的写法感到困惑，在网上很难找到合理解释。 分析 在上面这个方法中 <T>代表声明了一个 通用的泛型参数T T作为一个实际的占位符，代表返回值为T类型，实际返回类型只会在使用非泛型类型参数调用时才会确定。 如果这里不定义<T>,那么编译器将认为类型T不存在。 举例来说： 如果你..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-04T17:19:22.000Z"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"泛型"}],["meta",{"property":"article:published_time","content":"2021-09-30T13:01:16.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-04T17:19:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java <T> T 和 T的区别\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-09-30T13:01:16.000Z\\",\\"dateModified\\":\\"2024-04-04T17:19:22.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"导读","slug":"导读","link":"#导读","children":[]},{"level":2,"title":"分析","slug":"分析","link":"#分析","children":[]},{"level":2,"title":"扩展","slug":"扩展","link":"#扩展","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"updatedTime":1712251162000,"contributors":[{"name":"yushen","email":"85443289+yushenw@users.noreply.github.com","commits":1}]},"autoDesc":true,"filePathRelative":"posts/java/<T> T 和 T的区别.md","excerpt":"<h2>导读</h2>\\n<p>最近在看Java的过程中对形如<code>public &lt;T&gt; T get(...)</code>的写法感到困惑，在网上很难找到合理解释。</p>\\n<h2>分析</h2>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">public</span> <span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">T</span><span class=\\"token punctuation\\">&gt;</span></span> <span class=\\"token class-name\\">T</span> <span class=\\"token function\\">readObjectData</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">ByteBuffer</span> buffer<span class=\\"token punctuation\\">,</span> <span class=\\"token class-name\\">Class</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">T</span><span class=\\"token punctuation\\">&gt;</span></span> type<span class=\\"token punctuation\\">)</span> \\n</code></pre></div>"}');export{b as comp,y as data};
